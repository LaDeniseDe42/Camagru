Built-in web server ¶
Warning
This web server is designed to aid application development. It may also be useful for testing purposes or for application demonstrations that are run in controlled environments. It is not intended to be a full-featured web server. It should not be used on a public network.

The CLI SAPI provides a built-in web server.

The web server runs only one single-threaded process, so PHP applications will stall if a request is blocked.

URI requests are served from the current working directory where PHP was started, unless the -t option is used to specify an explicit document root. If a URI request does not specify a file, then either index.php or index.html in the given directory are returned. If neither file exists, the lookup for index.php and index.html will be continued in the parent directory and so on until one is found or the document root has been reached. If an index.php or index.html is found, it is returned and $_SERVER['PATH_INFO'] is set to the trailing part of the URI. Otherwise a 404 response code is returned.

If a PHP file is given on the command line when the web server is started it is treated as a "router" script. The script is run at the start of each HTTP request. If this script returns false, then the requested resource is returned as-is. Otherwise the script's output is returned to the browser.

Standard MIME types are returned for files with extensions: .3gp, .apk, .avi, .bmp, .css, .csv, .doc, .docx, .flac, .gif, .gz, .gzip, .htm, .html, .ics, .jpe, .jpeg, .jpg, .js, .kml, .kmz, .m4a, .mov, .mp3, .mp4, .mpeg, .mpg, .odp, .ods, .odt, .oga, .ogg, .ogv, .pdf, .png, .pps, .pptx, .qt, .svg, .swf, .tar, .text, .tif, .txt, .wav, .webm, .wmv, .xls, .xlsx, .xml, .xsl, .xsd, .zip .

As of PHP 7.4.0, the built-in webserver can be configured to fork multiple workers in order to test code that requires multiple concurrent requests to the built-in webserver. Set the PHP_CLI_SERVER_WORKERS environment variable to the number of desired workers before starting the server.

Note: This feature is not supported on Windows.

Warning
This experimental feature is not intended for production usage. Generally, the built-in Web Server is not intended for production usage.

Example #1 Starting the web server

$ cd ~/public_html
$ php -S localhost:8000
The terminal will show:

PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
After URI requests for http://localhost:8000/ and http://localhost:8000/myscript.html the terminal will show something similar to:

PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
Note that prior to PHP 7.4.0, symlinked statical resources have not been accessible on Windows, unless the router script would handle these.

Example #2 Starting with a specific document root directory

$ cd ~/public_html
$ php -S localhost:8000 -t foo/
The terminal will show:

PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
Example #3 Using a Router Script

In this example, requests for images will display them, but requests for HTML files will display "Welcome to PHP":

<?php
// router.php
if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"])) {
    return false;    // serve the requested resource as-is.
} else { 
    echo "<p>Welcome to PHP</p>";
}
?>
$ php -S localhost:8000 router.php
Example #4 Checking for CLI Web Server Use

To reuse a framework router script during development with the CLI web server and later also with a production web server:

<?php
// router.php
if (php_sapi_name() == 'cli-server') {
    /* route static assets and return false */
}
/* go on with normal index.php operations */
?>
$ php -S localhost:8000 router.php
Example #5 Handling Unsupported File Types

If you need to serve a static resource whose MIME type is not handled by the CLI web server, use:

<?php
// router.php
$path = pathinfo($_SERVER["SCRIPT_FILENAME"]);
if ($path["extension"] == "el") {
    header("Content-Type: text/x-script.elisp");
    readfile($_SERVER["SCRIPT_FILENAME"]);
}
else {
    return FALSE;
}
?>
$ php -S localhost:8000 router.php
Example #6 Accessing the CLI Web Server From Remote Machines

You can make the web server accessible on port 8000 to any interface with:

$ php -S 0.0.0.0:8000
Warning
The built-in Web Server should not be used on a public network.

Found A Problem?
Learn How To Improve This Page • Submit a Pull Request • Report a Bug
＋add a note
User Contributed Notes 10 notes
up
down
134jonathan at reinink dot ca ¶11 years ago
In order to set project specific configuration options, simply add a php.ini file to your project, and then run the built-in server with this flag:

php -S localhost:8000 -c php.ini

This is especially helpful for settings that cannot be set at runtime (ini_set()).
up
down
74Mark Simon ¶8 years ago
It’s not mentioned directly, and may not be obvious, but you can also use this to create a virtual host. This, of course, requires the help of your hosts file.

Here are the steps:

1    /etc/hosts
    127.0.0.1    www.example.com

2    cd [root folder]
    php -S www.example.com:8000

3    Browser:
    http://www.example.com:8000/index.php

Combined with a simple SQLite database, you have a very handy testing environment.
up
down
55oan at vizrt dot com ¶8 years ago
I painfully experienced behaviour that I can't seem to find documented here so I wanted to save everyone from repeating my mistake by giving the following heads up:

When starting php -S on a mac (in my case macOS Sierra) to host a local server, I had trouble with connecting from legacy Java. 

As it turned out, if you started the php server with 
"php -S localhost:80" 
the server will be started with ipv6 support only!

To access it via ipv4, you need to change the start up command like so:
 "php -S 127.0.0.1:80"
which starts server in ipv4 mode only.
up
down
30tamas at bartatamas dot hu ¶10 years ago
If your URI contains a dot, you'll lose the $_SERVER['PATH_INFO'] variable, when using the built-in webserver.
I wanted to write an API, and use .json ending in the URI-s, but then the framework's routing mechanism broke, and it took a lot of time to discover that the reason behind it was its router relying on $_SERVER['PATH_INFO'].

References:
https://bugs.php.net/bug.php?id=61286
up
down
25matthes at leuffen dot de ¶8 years ago
To output debugging information on the command line you can write output to php://stdout:

<?php
$path = $_SERVER["SCRIPT_FILENAME"];

file_put_contents("php://stdout", "\nRequested: $path");
echo "<p>Hello World</p>";
?>
up
down
28Ivan Ferrer ¶11 years ago
On Windows you may find useful to have a phpserver.bat file in shell:sendto with the folowing:
explorer http://localhost:8888
rem check if arg is file or dir
if exist "%~1\" (
  php -S localhost:8888 -t "%~1"
) else (
  php -S localhost:8888 -t "%~dp1"
)

then for fast web testing you only have to SendTo a file or folder to this bat and it will open your explorer and run the server.
up
down
8deep at deepshah dot me ¶4 years ago
Listen on all addresses of IPv4:
php -S 0.0.0.0:80

Listen on all addresses of IPv6:
php -S [::0]:80
up
down
1sony at sony-ak dot com ¶5 years ago
To send environment variable as long as with PHP built-in web server, type like this.

~$ MYENV=dev php -d variables_order=EGPCS -S 0.0.0.0:8000

On PHP script we can check with this code.

<?php
  echo getenv('MYENV'); // print dev
up
down
-1dachund at gmail dot com ¶7 years ago
I fiddled around with the internal webserver and had issues regarding handling static files, that do not contain a dot and a file extension.

The webserver responded with 200 without any content for files with URIs like "/testfile".

I am not certain if this is a bug, but I created a router.php that now does not use the "return false;" operation in order to pass thru the static file by the internal webserver.

Instead I use fpassthru() to do that.

In addition to that, my router.php can be configured to...
- ... have certain index files, when requesting a directory
- ... configure regex routes, so that, if the REQUEST_URI matches the regex, a certain file or directory is requested instead. (something you would do with nginx config or .htaccess ModRewrite)

Maybe someone finds this helpful.

================================

<?php

$indexFiles = ['index.html', 'index.php'];
$routes = [
  '^/api(/.*)?$' => '/index.php'
];

$requestedAbsoluteFile = dirname(__FILE__) . $_SERVER['REQUEST_URI'];

// check if the the request matches one of the defined routes
foreach ($routes as $regex => $fn)
{
  if (preg_match('%'.$regex.'%', $_SERVER['REQUEST_URI']))
  {
    $requestedAbsoluteFile = dirname(__FILE__) . $fn;
    break;
  }
}

// if request is a directory call check if index files exist
if (is_dir($requestedAbsoluteFile))
{
  foreach ($indexFiles as $filename)
  {
    $fn = $requestedAbsoluteFile.'/'.$filename;
    if (is_file($fn))
    {
      $requestedAbsoluteFile = $fn;
      break;
    }
  }
}

// if requested file does not exist or is directory => 404
if (!is_file($requestedAbsoluteFile))
{
  header($_SERVER['SERVER_PROTOCOL'].' 404 Not Found');
  printf('"%s" does not exist', $_SERVER['REQUEST_URI']);
  return true;
}

// if requested file is'nt a php file
if (!preg_match('/\.php$/', $requestedAbsoluteFile)) {
  header('Content-Type: '.mime_content_type($requestedAbsoluteFile));
  $fh = fopen($requestedAbsoluteFile, 'r');
  fpassthru($fh);
  fclose($fh);
  return true;
}

// if requested file is php, include it
include_once $requestedAbsoluteFile;
up
down
-2devoldemar ¶1 year ago
Built-in web server uses SAPI logging subsystem. Therefore all messages are written to standard error, and not to standard output stream.
If you want to save server logs into a file, the following command will work:
php -S 0.0.0.0:80 2>&1 | tee out.log


Environnement et Déploiement
Docker + Docker Compose : Conteneurisation pour permettre un déploiement en un seul clic.
Serveur Web : Apache ou Nginx (selon préférence).
Base de Données : MySQL ou PostgreSQL.
🖥️ Back-end (Serveur)
Langage : PHP (uniquement avec la bibliothèque standard).
Sécurité :
Hachage des mots de passe (ex. password_hash()).
Protection contre les injections SQL (requêtes préparées).
Validation et évasion des entrées utilisateurs (filter_var(), htmlspecialchars()).
Vérification CSRF (tokens CSRF pour les formulaires).
Restriction sur les types de fichiers uploadés.
Architecture : MVC recommandé pour une bonne structure.
Gestion des emails : mail() ou une alternative en PHP standard pour la confirmation et les notifications.
🎨 Front-end (Client)
Langages : HTML, CSS, JavaScript.
CSS Framework : Bootstrap ou TailwindCSS (si pas de JS intégré).
Fonctionnalités :
Formulaires validés côté client (HTML5, JavaScript).
API getUserMedia() pour capturer la webcam (gérer l’absence de HTTPS).
Gestion de l’upload d’images.
Affichage dynamique avec JavaScript natif (sans frameworks JS).
Compatibilité : Tests avec Firefox (>=41) et Chrome (>=46).
📸 Gestion des Images
Superposition d’images : Traitement côté serveur en PHP avec GD ou Imagick.
Stockage sécurisé : Empêcher l’exécution de fichiers uploadés.
Pagination des images : Affichage de 5 éléments par page.
🔐 Gestion des Comptes Utilisateurs
Inscription avec validation par email.
Connexion avec hachage sécurisé des mots de passe.
Gestion des sessions en PHP.
Réinitialisation de mot de passe via email.
Mise à jour des informations du compte.
📜 Récapitulatif des Besoins
Composant	Technologie
Serveur Web	Apache / Nginx
Langage Serveur	PHP (sans frameworks)
Base de Données	MySQL / PostgreSQL
Front-end	HTML, CSS, JS natif
Gestion des images	PHP GD / Imagick
Sécurité	Hashing, SQL Injection, CSRF, XSS
Déploiement	Docker, Docker Compose
